<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>译：Tasks, microtasks, queues and schedules | Kawhi's blogs</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/todo">Todo</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Node/">Node</a><a class="post-tag-link" href="/tags/外文翻译/">外文翻译</a></div><div class="post-time">2019-05-22</div></div></div><div class="container post-header"><h1>译：Tasks, microtasks, queues and schedules</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">目录</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#关于作者"><span class="toc-number">1.</span> <span class="toc-text">关于作者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#任务，微任务，队列和时间表"><span class="toc-number">2.</span> <span class="toc-text">任务，微任务，队列和时间表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#试一试"><span class="toc-number">2.1.</span> <span class="toc-text">试一试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么会发生这种情况"><span class="toc-number">2.2.</span> <span class="toc-text">为什么会发生这种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么有些浏览器不是这样的？"><span class="toc-number">2.2.1.</span> <span class="toc-text">为什么有些浏览器不是这样的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如果同时使用了任务和微任务怎么区分"><span class="toc-number">2.3.</span> <span class="toc-text">如果同时使用了任务和微任务怎么区分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-1-bossfight"><span class="toc-number">2.4.</span> <span class="toc-text">Level 1 bossfight</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试"><span class="toc-number">2.5.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#谁是正确的"><span class="toc-number">2.6.</span> <span class="toc-text">谁是正确的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器哪里搞错的"><span class="toc-number">2.7.</span> <span class="toc-text">浏览器哪里搞错的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-1-boss’s-angry-older-brother"><span class="toc-number">2.8.</span> <span class="toc-text">Level 1 boss’s angry older brother</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#试一试-1"><span class="toc-number">2.9.</span> <span class="toc-text">试一试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么会不同"><span class="toc-number">2.10.</span> <span class="toc-text">为什么会不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#这重要吗"><span class="toc-number">2.11.</span> <span class="toc-text">这重要吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#你做到了"><span class="toc-number">2.12.</span> <span class="toc-text">你做到了</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tasks-microtasks-queues-and-schedules"><span class="toc-number">3.</span> <span class="toc-text">Tasks, microtasks, queues and schedules</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Try-it"><span class="toc-number">3.1.</span> <span class="toc-text">Try it</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-this-happens"><span class="toc-number">3.2.</span> <span class="toc-text">Why this happens</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-are-some-browsers-doing-differently"><span class="toc-number">3.2.1.</span> <span class="toc-text">What are some browsers doing differently?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-to-tell-if-something-uses-tasks-or-microtasks"><span class="toc-number">3.3.</span> <span class="toc-text">How to tell if something uses tasks or microtasks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-1-bossfight-1"><span class="toc-number">3.4.</span> <span class="toc-text">Level 1 bossfight</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Test-it"><span class="toc-number">3.5.</span> <span class="toc-text">Test it</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Who’s-right"><span class="toc-number">3.6.</span> <span class="toc-text">Who’s right?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-did-browsers-get-wrong"><span class="toc-number">3.7.</span> <span class="toc-text">What did browsers get wrong?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-1-boss’s-angry-older-brother-1"><span class="toc-number">3.8.</span> <span class="toc-text">Level 1 boss’s angry older brother</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Try-it-1"><span class="toc-number">3.9.</span> <span class="toc-text">Try it</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-is-it-different"><span class="toc-number">3.10.</span> <span class="toc-text">Why is it different?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Does-any-of-this-matter"><span class="toc-number">3.11.</span> <span class="toc-text">Does any of this matter?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#You-made-it"><span class="toc-number">3.12.</span> <span class="toc-text">You made it!</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>原文出自：<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a>，强烈建议您读一遍原文，很幽默，也很有趣。很多涉及 Event Loop 的讨论不约而同的都引用到了这篇文章，比如<a href="https://imweb.io/topic/5b148768d4c96b9b1b4c4ea1" target="_blank" rel="noopener">理解event loop</a>，我决定把它翻译一遍。</p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/jake.jpg" alt=""></p>
<p><a href="https://jakearchibald.com/" target="_blank" rel="noopener">Jake Archibald</a>，谷歌公司的一位技术布道者（<a href="https://www.zhihu.com/question/52479600?sort=created" target="_blank" rel="noopener">developer advocate</a>）。</p>
<h1 id="任务，微任务，队列和时间表"><a href="#任务，微任务，队列和时间表" class="headerlink" title="任务，微任务，队列和时间表"></a>任务，微任务，队列和时间表</h1><p>当我告诉我的同事 <a href="https://twitter.com/gauntface" target="_blank" rel="noopener">Matt Gaunt</a> 我正在考虑写一篇关于微任务队列和浏览器事件循环执行机制的文章时，他说：“老实说，我不会去读的”。好吧，不管怎么样，我已经写了，我们一起坐下来欣赏一下吧，好吗？</p>
<p>事实上，如果你更喜欢视频，<a href="https://twitter.com/philip_roberts" target="_blank" rel="noopener">Philip Roberts</a> 在 JSConf 上就事件循环做了一次很好的演讲，虽然微任务并没有被提及，但它是对本文余下内容的一个很好的介绍。总之，我们开始吧。。。</p>
<p>先来一点儿 JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>
<p>日志会以怎样的顺序打印出来 ？</p>
<h2 id="试一试"><a href="#试一试" class="headerlink" title="试一试"></a>试一试</h2><p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test-0.png" alt=""></p>
<p><em>注：这只是一张截图</em></p>
<p>正确的答案是：<code>script start</code>，<code>script end</code>，<code>promise1</code>，<code>promise2</code>，<code>setTimeout</code>，但在不同的浏览器上，它的表现很不一致。</p>
<p>在 Microsoft Edge，Firefox 40，iOS Safari 和 desktop Safari 8.0.8 上面，<code>setTimeout</code> 在 <code>promise1</code> 和 <code>promise2</code> 之前被打印出来，这似乎是一个竞争的场景（race conditioin）。这真的很奇怪，因为 Firefox 39 和 Safari 8.0.7 都打印出了正确的结果。</p>
<h2 id="为什么会发生这种情况"><a href="#为什么会发生这种情况" class="headerlink" title="为什么会发生这种情况"></a>为什么会发生这种情况</h2><p>要想理解这种情况你需要知道事件循环是如何处理任务（tasks）和微任务（microtasks）的。如果是第一次听到这个的话，可能会有很多东西需要认真研究。深呼吸。。。</p>
<p>每个线程（thread）有自己的事件循环，因此每个 web worker 都有它自己事件循环能够独立执行，然而在同一个域下的所有窗口会共享一个事件循环，就好像它们可以同步通信一样。事件循环不停地在运转执行任意一个排队的任务。一个事件循环有多个任务源（像 <a href="http://w3c.github.io/IndexedDB/#introduction" target="_blank" rel="noopener">IndexedDB</a> 一样，会有规范来定义这些任务源），这些任务源（task source）保证了任务的执行顺序，但在每个循环中，浏览器可以选择要执行的任务源。这使得浏览器可以优先选择那些对性能敏感的任务，比如用户输入（user-input）。好吧好吧，跟上我的思路。。。</p>
<p>无论从内部构件还是到 JavaScript/DOM 层面，任务都是被预先安排好的，浏览器可以选择并确保这些任务顺序的执行。在任务的执行间隔，浏览器可能会去渲染界面的更新。从一个鼠标点击任务到一个事件回调需要安排一个任务，还有像解析 HTML，以及上面的例子中提到的定时器 <code>setTimeout</code>。</p>
<p><code>setTimeout</code> 会等待一个给定的延迟时间然后才会为它的回调函数安排一个新的任务。这就是为什么 <code>setTimeout</code> 在 <code>script end</code> 之后打印出来，因为打印 <code>script end</code> 是属于第一个任务，而 <code>setTimeout</code> 在一个单独的任务中打印出来。好吧，我们就快过去了，但我还需要你为接下来的一点儿内容坚持。。。</p>
<p>微任务（Microtasks）通常用来安排那些应该在当前的脚本运行结束之后需要被立即执行的任务，比如响应一个批量的动作，或者某些异步动作不用麻烦要去创建一个全新的任务。在每一个任务结束之后，或者是回调函数执行完毕之后，只要没有其他正在执行（mid-execution）的 JavaScript 脚本，微任务队列就会开始运行。在微任务执行中产生的其他任意的微任务也会被添加到微任务队列的末端并执行。微任务包括 MutationObserver 回调函数，还有上面的例子中提到的，Promise 回调函数。</p>
<p>Promise 一旦被解决，或者它已经被解决了，它会立即为它的回调函数安排一个微任务。这确保了 promise 回调函数异步执行，即使这个 promise 已经被解决了。因此调用一个已经解决的 promise 的 <code>then(yey, nay)</code> 会立即安排一个微任务。这就是为什么 <code>promise1</code> 和 <code>promise2</code> 会在 <code>script end</code> 之后被打印出来，因为当前运行的脚本必须在微任务被处理之前结束。<code>promise1</code> 和 <code>promise2</code> 在 <code>setTimeout</code> 之前打印出来，因为微任务总是在下一个任务之前发生。</p>
<p>来吧，一步一步：</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/animate.png" alt=""></p>
<p><em>注：这只是一张截图</em></p>
<p>是的，我创建了一个分步的动态图（这里可动不了）。你的周六怎么过的？和你的朋友出去晒太阳吗？好吧，我没有。以防我天才的 UI 设计表达的不清楚，可以点击上面的箭头来往前走。</p>
<h3 id="为什么有些浏览器不是这样的？"><a href="#为什么有些浏览器不是这样的？" class="headerlink" title="为什么有些浏览器不是这样的？"></a>为什么有些浏览器不是这样的？</h3><p>一些浏览器会打出 <code>script start</code>，<code>script end</code>，<code>setTimeout</code>，<code>promise1</code>，<code>promise2</code>。它们在 <code>setTimeout</code> 之后运行 promise 回调函数。可能是因为这些浏览器把 promise 回调函数作为新任务的一部分而不是作为一个微任务去调用。</p>
<p>这其实也可以理解，因为 promise 来自 ECMAScript 而不是 HTML。ECMAScript 有 “jobs” 的概念，它和微任务类似，但从一些模糊不清的讨论（<a href="https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16" target="_blank" rel="noopener">vague mailing list discussions</a>）中，他们的关系并不明确。但是，出于一些好的理由，一致的认识是 promises 应该作为微任务队列的一部分去安排和执行。</p>
<p>把 promises 作为任务去处理会导致一些性能问题，比如回调函数可能会因为任务相关的事情产生不必要的延迟，比如界面渲染。也可能对与其他任务源的交互产生一些非决定性的因素，还会中断与其他 API 的交互，还有更多稍后再提。</p>
<p>这里是一个 Edge 将 promises 作为微任务处理的一个声明。WebKit 正在做正确的事情，因此我假设 Safari 最终也会选择修复这个问题，Firefox 43 似乎在 已经被修复掉了。</p>
<p>有趣的是，自从 Safari 和 Firefox 修复之后又做了回退，我想知道这是不是仅仅是个巧合。</p>
<h2 id="如果同时使用了任务和微任务怎么区分"><a href="#如果同时使用了任务和微任务怎么区分" class="headerlink" title="如果同时使用了任务和微任务怎么区分"></a>如果同时使用了任务和微任务怎么区分</h2><p>测试是一种方式。看 promises 和 <code>setTimeout</code> 日志出现的相对顺序，尽管你得依赖它们的实现是正确的。</p>
<p>有把握的一种方式是查阅规范。比如，<a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timer-initialisation-steps" target="_blank" rel="noopener"><code>setTimeout</code> 规范的第 14 点</a>指出它安排了一个任务，而 <a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" target="_blank" rel="noopener">MutationObserver 规范的第 5 点</a>指出它安排了一个微任务。</p>
<p>之前提到，在 ECMAScript 的世界里，它们把微任务称为 “jobs”。在 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen" target="_blank" rel="noopener">PerformPromiseThen</a> 的第 8 点指出，<code>EnqueueJob</code> 被调用去安排一个微任务。</p>
<p>现在让我们看一个更复杂的例子。我有种预感：不，他们还没有准备好。但我决定忽略它，你已经准备好了，我们继续吧。。。</p>
<h2 id="Level-1-bossfight"><a href="#Level-1-bossfight" class="headerlink" title="Level 1 bossfight"></a>Level 1 bossfight</h2><p>在写这篇文章之前，我把下面的问题搞错了。这里是一部分 html：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"inner"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>给出下面的 JS，当我点击 <code>div.inner</code> 时，什么会被打出来？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Let's get hold of those elements</span></span><br><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">'.outer'</span>);</span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let's listen for attribute changes on the</span></span><br><span class="line"><span class="comment">// outer element</span></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mutate'</span>);</span><br><span class="line">&#125;).observe(outer, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here's a click listener…</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  outer.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// …which we'll attach to both elements</span></span><br><span class="line">inner.addEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line">outer.addEventListener(<span class="string">'click'</span>, onClick);</span><br></pre></td></tr></table></figure>
<p>继续，在看答案前试一下。提示：日志可能会打印超过一次。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>点击内部的正方形触发一个点击事件：</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test.png" alt=""></p>
<p><em>注：这里只是在 Chrome 下的执行结果截图</em></p>
<p>你猜的一样吗？如果不一样，你也可能是正确的。不幸的是，浏览器在这里的表现并不一致。</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test-result.png" alt=""></p>
<h2 id="谁是正确的"><a href="#谁是正确的" class="headerlink" title="谁是正确的"></a>谁是正确的</h2><p>分发 “click” 事件是一个任务。Mutation observer 和 promise 被作为微任务安排。<code>setTimeout</code> 回调函数被作为任务安排。所以这里是这样的：</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/animate-1.png" alt=""></p>
<p><em>注：这只是一张截图</em></p>
<p>因此，Chrome 是对的。我有一点儿没想到的是，微任务是在回调函数之后（只要没有其他的 JavaScript 脚本正在运行）被执行的，我以为它仅限于任务结尾。这个规则来自 HTML 规范对调用回调函数的说明：</p>
<blockquote>
<p>If the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects" target="_blank" rel="noopener">stack of script settings objects</a> is now empty, <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener">perform a microtask checkpoint</a><br>— <a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback" target="_blank" rel="noopener">HTML: Cleaning up after a callback</a> step 3</p>
</blockquote>
<p>。。。并且一个微任务检查节点包含了微任务队列的检查，除非我们已经执行过微任务队列。类似的，ECMAScript 对 “jobs” 是这样描述的：</p>
<blockquote>
<p>Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty…<br>— <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" target="_blank" rel="noopener">ECMAScript: Jobs and Job Queues</a></p>
</blockquote>
<p>。。。尽管在一个 HTML 上下文中，”can be” 变成了 “must be”。</p>
<h2 id="浏览器哪里搞错的"><a href="#浏览器哪里搞错的" class="headerlink" title="浏览器哪里搞错的"></a>浏览器哪里搞错的</h2><p>Firefox 和 Safari 在点击事件的监听函数之间正确地耗尽了微任务队列，就像 mutation 回调函数表现出的那样，但 promises 的安排似乎是不同的。考虑到 “jobs” 和 微任务是很模糊的，这可以理解，但我仍然期望他们在监听函数之间去执行。<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1193394" target="_blank" rel="noopener">Firefox 声明</a>。<a href="https://bugs.webkit.org/show_bug.cgi?id=147933" target="_blank" rel="noopener">Safari 声明</a>。</p>
<p>我们已经看到 Edge 对 promises 的安排是错误的，它也没有在点击事件回调函数之间耗尽微任务队列，而是在调用所有的事件监听函数之后做的，这可以解释为什么在 <code>click</code> 打印之后，一个 <code>mutate</code> 日志被打印了出来。<a href="https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners" target="_blank" rel="noopener">Bug 声明</a>。</p>
<h2 id="Level-1-boss’s-angry-older-brother"><a href="#Level-1-boss’s-angry-older-brother" class="headerlink" title="Level 1 boss’s angry older brother"></a>Level 1 boss’s angry older brother</h2><p>使用上面的同样的例子，如果我们这样执行会发生什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inner.click();</span><br></pre></td></tr></table></figure>
<h2 id="试一试-1"><a href="#试一试-1" class="headerlink" title="试一试"></a>试一试</h2><p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test-1.png" alt=""></p>
<p><em>注：这只是一张截图</em></p>
<p>这里是不同浏览器的执行结果：</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test-result-1.png" alt=""></p>
<p>我发誓我在 Chrome 上一直得到不同的结果，考虑到我之前测试可能的失误，这个图我已经更新了好多次了。如果你在 Chrome 下看到不同的结果，在评论中告诉我它的版本。</p>
<h2 id="为什么会不同"><a href="#为什么会不同" class="headerlink" title="为什么会不同"></a>为什么会不同</h2><p>它应该这样运行：</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/animate-2.png" alt=""></p>
<p><em>注：这只是一张截图</em></p>
<p>因此正确的顺序是：<code>click</code>，<code>click</code>，<code>promise</code>，<code>mutate</code>，<code>promise</code>，<code>timeout</code>，<code>timeout</code>，Chrome 似乎做对了。</p>
<p>在每一个监听函数之后被调用。。。</p>
<blockquote>
<p>If the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects" target="_blank" rel="noopener">stack of script settings objects</a> is now empty, <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener">perform a microtask checkpoint</a><br>— <a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback" target="_blank" rel="noopener">HTML: Cleaning up after a callback</a> step 3</p>
</blockquote>
<p>之前，这意思是说微任务在监听函数之间运行，但 <code>.click()</code> 使得这个事件同步分发，因此在回调函数之间，调用 <code>.click()</code> 的脚本仍然保留在执行栈中。上面的规则确保了微任务不会中断正在运行中的 JavaScript 脚本。这意味着我们不会在事件监听函数之间执行微任务队列，它们是在全部的事件监听函数执行完之后执行的。</p>
<h2 id="这重要吗"><a href="#这重要吗" class="headerlink" title="这重要吗"></a>这重要吗</h2><p>是的，它可能在不经意间给你带来麻烦。我曾遇到过，当时我正在尝试<a href="https://github.com/jakearchibald/indexeddb-promised/blob/master/lib/idb.js" target="_blank" rel="noopener">使用 promises 而不是奇怪的 <code>IDBRequest</code> 对象 为 IndexedDB 创建一个简单的包装器库</a>。它几乎使得<a href="https://github.com/jakearchibald/indexeddb-promised/blob/master/test/idb.js#L36" target="_blank" rel="noopener">使用 IDB 变得很有趣</a>。</p>
<p>当 IDB 触发了一个成功的事件，相关的<a href="http://w3c.github.io/IndexedDB/#fire-a-success-event" target="_blank" rel="noopener">事物对象在分发之后失活</a>（第四步）。如果我创建一个 promise 在这个事件触发的时候 <code>resolve</code>，回调函数应该在第四步之前运行，而此时事务仍然处于活动状态，但它在 Chrome 之外的浏览器中并没有发生，这个库变得没什么用了。</p>
<p>事实上在 Firefox 中，你可以解决这个问题，因为像 <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="noopener">es6-promise</a> 这样的 promise 实现库使用 mutation observers 作为回调函数，它正确的作为微任务来使用。Safari 似乎从那次修复之后还存在竞争的情况，但那可能仅仅是它们的残缺的实现。不幸的是在 IE/Edge 中，一直是错误的，因为 mutation 事件不会在回调函数之后处理。</p>
<p>希望我们将很快看到一些试验性的改进。</p>
<h2 id="你做到了"><a href="#你做到了" class="headerlink" title="你做到了"></a>你做到了</h2><p>总结：</p>
<ul>
<li>任务按顺序执行，浏览器可能在任务之间执行界面渲染</li>
<li>微任务按顺序执行，并且是在下面的情况下执行：<ul>
<li>在每一个回调函数执行之后，只要没有其它正在运行的 JavaScript 脚本</li>
<li>在每一个任务的末尾</li>
</ul>
</li>
</ul>
<p>希望你现在对事件循环有了自己的理解，或者至少有一个理由去躺下来想一想。</p>
<p>说真的，还有人在读吗？在吗？在吗？</p>
<p>感谢 Anne van Kesteren，Domenic Denicola，Brian Kardell 和 Matt Gaunt 对本文的校正和修改。是的，最后 Matt 读了这篇文章，我甚至不需要去提醒他。</p>
<h1 id="Tasks-microtasks-queues-and-schedules"><a href="#Tasks-microtasks-queues-and-schedules" class="headerlink" title="Tasks, microtasks, queues and schedules"></a>Tasks, microtasks, queues and schedules</h1><p>When I told my colleague Matt Gaunt I was thinking of writing a piece on microtask queueing and execution within the browser’s event loop, he said “I’ll be honest with you Jake, I’m not going to read that”. Well, I’ve written it anyway, so we’re all going to sit here and enjoy it, ok?</p>
<p>Actually, if video’s more your thing, Philip Roberts gave a great talk at JSConf on the event loop - microtasks aren’t covered, but it’s a great introduction to the rest. Anyway, on with the show…</p>
<p>Take this little bit of JavaScript:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>
<p>In what order should the logs appear?</p>
<h2 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it"></a>Try it</h2><p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test-0.png" alt=""></p>
<p>The correct answer: <code>script start</code>, <code>script end</code>, <code>promise1</code>, <code>promise2</code>, <code>setTimeout</code>, but it’s pretty wild out there in terms of browser support.</p>
<p>Microsoft Edge, Firefox 40, iOS Safari and desktop Safari 8.0.8 log <code>setTimeout</code> before <code>promise1</code> and <code>promise2</code> - although it appears to be a race condition. This is really weird, as Firefox 39 and Safari 8.0.7 get it consistently right.</p>
<h2 id="Why-this-happens"><a href="#Why-this-happens" class="headerlink" title="Why this happens"></a>Why this happens</h2><p>To understand this you need to know how the event loop handles tasks and microtasks. This can be a lot to get your head around the first time you encounter it. Deep breath…</p>
<p>Each ‘thread’ gets its own <strong>event loop</strong>, so each web worker gets its own, so it can execute independently, whereas all windows on the same origin share an event loop as they can synchronously communicate. The event loop runs continually, executing any tasks queued. An event loop has multiple task sources which guarantees execution order within that source (specs <a href="http://w3c.github.io/IndexedDB/#database-access-task-source" target="_blank" rel="noopener">such as IndexedDB</a> define their own), but the browser gets to pick which source to take a task from on each turn of the loop. This allows the browser to give preference to performance sensitive tasks such as user-input. Ok ok, stay with me…</p>
<p><strong>Tasks</strong> are scheduled so the browser can get from its internals into JavaScript/DOM land and ensures these actions happen sequentially. Between tasks, the browser may render updates. Getting from a mouse click to an event callback requires scheduling a task, as does parsing HTML, and in the above example, <code>setTimeout</code>.</p>
<p><code>setTimeout</code> waits for a given delay then schedules a new task for its callback. This is why <code>setTimeout</code> is logged after <code>script end</code>, as logging <code>script end</code> is part of the first task, and <code>setTimeout</code> is logged in a separate task. Right, we’re almost through this, but I need you to stay strong for this next bit…</p>
<p><strong>Microtasks</strong> are usually scheduled for things that should happen straight after the currently executing script, such as reacting to a batch of actions, or to make something async without taking the penalty of a whole new task. The microtask queue is processed after callbacks as long as no other JavaScript is mid-execution, and at the end of each task. Any additional microtasks queued during microtasks are added to the end of the queue and also processed. Microtasks include mutation observer callbacks, and as in the above example, promise callbacks.</p>
<p>Once a promise settles, or if it has already settled, it queues a microtask for its reactionary callbacks. This ensures promise callbacks are async even if the promise has already settled. So calling <code>.then(yey, nay)</code> against a settled promise immediately queues a microtask. This is why <code>promise1</code> and <code>promise2</code> are logged after <code>script end</code>, as the currently running script must finish before microtasks are handled. <code>promise1</code> and <code>promise2</code> are logged before <code>setTimeout</code>, as microtasks always happen before the next task.</p>
<p>So, step by step:</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/animate.png" alt=""></p>
<p>Yes that’s right, I created an animated step-by-step diagram. How did you spend your Saturday? Went out in the sun with your friends? Well I didn’t. Um, in case it isn’t clear from my amazing UI design, click the arrows above to advance.</p>
<h3 id="What-are-some-browsers-doing-differently"><a href="#What-are-some-browsers-doing-differently" class="headerlink" title="What are some browsers doing differently?"></a>What are some browsers doing differently?</h3><p>Some browsers log <code>script start</code>, <code>script end</code>, <code>setTimeout</code>, <code>promise1</code>, <code>promise2</code>. They’re running promise callbacks after <code>setTimeout</code>. It’s likely that they’re calling promise callbacks as part of a new task rather than as a microtask.</p>
<p>This is sort-of excusable, as promises come from ECMAScript rather than HTML. ECMAScript has the concept of “jobs” which are similar to microtasks, but the relationship isn’t explicit aside from <a href="https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16" target="_blank" rel="noopener">vague mailing list discussions</a>. However, the general consensus is that promises should be part of the microtask queue, and for good reason.</p>
<p>Treating promises as tasks leads to performance problems, as callbacks may be unnecessarily delayed by task-related things such as rendering. It also causes non-determinism due to interaction with other task sources, and can break interactions with other APIs, but more on that later.</p>
<p>Here’s <a href="https://connect.microsoft.com/IE/feedback/details/1658365" target="_blank" rel="noopener">an Edge ticket</a> for making promises use microtasks. WebKit nightly is doing the right thing, so I assume Safari will pick up the fix eventually, and it appears to be fixed in Firefox 43.</p>
<p>Really interesting that both Safari and Firefox suffered a regression here that’s since been fixed. I wonder if it’s just a coincidence.</p>
<h2 id="How-to-tell-if-something-uses-tasks-or-microtasks"><a href="#How-to-tell-if-something-uses-tasks-or-microtasks" class="headerlink" title="How to tell if something uses tasks or microtasks"></a>How to tell if something uses tasks or microtasks</h2><p>Testing is one way. See when logs appear relative to promises &amp; <code>setTimeout</code>, although you’re relying on the implementation to be correct.</p>
<p>The certain way, is to look up the spec. For instance, <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timer-initialisation-steps" target="_blank" rel="noopener">step 14 of setTimeout</a> queues a task, whereas <a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" target="_blank" rel="noopener">step 5 of queuing a mutation record</a> queues a microtask.</p>
<p>As mentioned, in ECMAScript land, they call microtasks “jobs”. In <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen" target="_blank" rel="noopener">step 8.a of <code>PerformPromiseThen</code></a>, <code>EnqueueJob</code> is called to queue a microtask.</p>
<p>Now, let’s look at a more complicated example. Cut to a concerned apprentice “No, they’re not ready!”. Ignore him, you’re ready. Let’s do this…</p>
<h2 id="Level-1-bossfight-1"><a href="#Level-1-bossfight-1" class="headerlink" title="Level 1 bossfight"></a>Level 1 bossfight</h2><p>Before writing this post I’d have gotten this wrong. Here’s a bit of html:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"outer"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"inner"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>Given the following JS, what will be logged if I click <code>div.inner</code>?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Let's get hold of those elements</span></span><br><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">'.outer'</span>);</span><br><span class="line"><span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">'.inner'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let's listen for attribute changes on the</span></span><br><span class="line"><span class="comment">// outer element</span></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mutate'</span>);</span><br><span class="line">&#125;).observe(outer, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here's a click listener…</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  outer.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// …which we'll attach to both elements</span></span><br><span class="line">inner.addEventListener(<span class="string">'click'</span>, onClick);</span><br><span class="line">outer.addEventListener(<span class="string">'click'</span>, onClick);</span><br></pre></td></tr></table></figure>
<p>Go on, give it a go before peeking at the answer. Clue: Logs can happen more than once.</p>
<h2 id="Test-it"><a href="#Test-it" class="headerlink" title="Test it"></a>Test it</h2><p>Click the inner square to trigger a click event:</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test.png" alt=""></p>
<p>Was your guess different? If so, you may still be right. Unfortunately the browsers don’t really agree here:</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test-result.png" alt=""></p>
<h2 id="Who’s-right"><a href="#Who’s-right" class="headerlink" title="Who’s right?"></a>Who’s right?</h2><p>Dispatching the ‘click’ event is a task. Mutation observer and promise callbacks are queued as microtasks. The <code>setTimeout</code> callback is queued as a task. So here’s how it goes:</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/animate-1.png" alt=""></p>
<p>So it’s Chrome that gets it right. The bit that was ‘news to me’ is that microtasks are processed after callbacks (as long as no other JavaScript is mid-execution), I thought it was limited to end-of-task. This rule comes from the HTML spec for calling a callback:</p>
<blockquote>
<p>If the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects" target="_blank" rel="noopener">stack of script settings objects</a> is now empty, <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener">perform a microtask checkpoint</a><br>— <a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback" target="_blank" rel="noopener">HTML: Cleaning up after a callback</a> step 3</p>
</blockquote>
<p>…and a microtask checkpoint involves going through the microtask queue, unless we’re already processing the microtask queue. Similarly, ECMAScript says this of jobs:</p>
<blockquote>
<p>Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty…<br>— <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" target="_blank" rel="noopener">ECMAScript: Jobs and Job Queues</a></p>
</blockquote>
<p>…although the “can be” becomes “must be” when in an HTML context.</p>
<h2 id="What-did-browsers-get-wrong"><a href="#What-did-browsers-get-wrong" class="headerlink" title="What did browsers get wrong?"></a>What did browsers get wrong?</h2><p><strong>Firefox</strong> and <strong>Safari</strong> are correctly exhausting the microtask queue between click listeners, as shown by the mutation callbacks, but promises appear to be queued differently. This is sort-of excusable given that the link between jobs &amp; microtasks is vague, but I’d still expect them to execute between listener callbacks. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1193394" target="_blank" rel="noopener">Firefox ticket</a>. <a href="https://bugs.webkit.org/show_bug.cgi?id=147933" target="_blank" rel="noopener">Safari ticket</a>.</p>
<p>With <strong>Edge</strong> we’ve already seen it queue promises incorrectly, but it also fails to exhaust the microtask queue between click listeners, instead it does so after calling all listeners, which accounts for the single <code>mutate</code> log after both <code>click</code> logs. <a href="https://connect.microsoft.com/IE/feedbackdetail/view/1658386/microtasks-queues-should-be-processed-following-event-listeners" target="_blank" rel="noopener">Bug ticket</a>.</p>
<h2 id="Level-1-boss’s-angry-older-brother-1"><a href="#Level-1-boss’s-angry-older-brother-1" class="headerlink" title="Level 1 boss’s angry older brother"></a>Level 1 boss’s angry older brother</h2><p>Ohh boy. Using the same example from above, what happens if we execute:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inner.click();</span><br></pre></td></tr></table></figure>
<p>This will start the event dispatching as before, but using script rather than a real interaction.</p>
<h2 id="Try-it-1"><a href="#Try-it-1" class="headerlink" title="Try it"></a>Try it</h2><p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test-1.png" alt=""></p>
<p>And here’s what the browsers say:</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/test-result-1.png" alt=""></p>
<p>And I swear I keep getting different results from Chrome, I’ve updated this chart a ton of times thinking I was testing Canary by mistake. If you get different results in Chrome, tell me which version in the comments.</p>
<h2 id="Why-is-it-different"><a href="#Why-is-it-different" class="headerlink" title="Why is it different?"></a>Why is it different?</h2><p>Here’s how it should happen:</p>
<p><img src="/2019/05/22/译：Tasks-microtasks-queues-and-schedules/animate-2.png" alt=""></p>
<p>So the correct order is: <code>click</code>, <code>click</code>, <code>promise</code>, <code>mutate</code>, <code>promise</code>, <code>timeout</code>, <code>timeout</code>, which Chrome seems to get right.</p>
<p>After each listener callback is called…</p>
<blockquote>
<p>If the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#stack-of-script-settings-objects" target="_blank" rel="noopener">stack of script settings objects</a> is now empty, <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener">perform a microtask checkpoint</a><br>— <a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback" target="_blank" rel="noopener">HTML: Cleaning up after a callback</a> step 3</p>
</blockquote>
<p>Previously, this meant that microtasks ran between listener callbacks, but <code>.click()</code> causes the event to dispatch synchronously, so the script that calls <code>.click()</code> is still in the stack between callbacks. The above rule ensures microtasks don’t interrupt JavaScript that’s mid-execution. This means we don’t process the microtask queue between listener callbacks, they’re processed after both listeners.</p>
<h2 id="Does-any-of-this-matter"><a href="#Does-any-of-this-matter" class="headerlink" title="Does any of this matter?"></a>Does any of this matter?</h2><p>Yeah, it’ll bite you in obscure places (ouch). I encountered this while trying to create <a href="https://github.com/jakearchibald/indexeddb-promised/blob/master/lib/idb.js" target="_blank" rel="noopener">a simple wrapper library for IndexedDB that uses promises</a> rather than weird <code>IDBRequest</code> objects. It <a href="https://github.com/jakearchibald/indexeddb-promised/blob/master/test/idb.js#L36" target="_blank" rel="noopener">almost makes IDB fun to use</a>.</p>
<p>When IDB fires a success event, the related <a href="http://w3c.github.io/IndexedDB/#fire-a-success-event" target="_blank" rel="noopener">transaction object becomes inactive after dispatching</a> (step 4). If I create a promise that resolves when this event fires, the callbacks should run before step 4 while the transaction is still active, but that doesn’t happen in browsers other than Chrome, rendering the library kinda useless.</p>
<p>You can actually work around this problem in Firefox, because promise polyfills such as <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="noopener">es6-promise</a> use mutation observers for callbacks, which correctly use microtasks. Safari seems to suffer from race conditions with that fix, but that could just be their <a href="http://www.raymondcamden.com/2014/09/25/IndexedDB-on-iOS-8-Broken-Bad" target="_blank" rel="noopener">broken implementation of IDB</a>. Unfortunately, things consistently fail in IE/Edge, as mutation events aren’t handled after callbacks.</p>
<p>Hopefully we’ll start to see some interoperability here soon.</p>
<h2 id="You-made-it"><a href="#You-made-it" class="headerlink" title="You made it!"></a>You made it!</h2><p>In summary:</p>
<ul>
<li>Tasks execute in order, and the browser may render between them</li>
<li>Microtasks execute in order, and are executed:<ul>
<li>after every callback, as long as no other JavaScript is mid-execution</li>
<li>at the end of each task</li>
</ul>
</li>
</ul>
<p>Hopefully you now know your way around the event loop, or at least have an excuse to go and have a lie down.</p>
<p>Actually, is anyone still reading? Hello? Hello?</p>
<p>Thanks to Anne van Kesteren, Domenic Denicola, Brian Kardell, and Matt Gaunt for proofreading &amp; corrections. Yeah, Matt actually read it in the end, I didn’t even need to go full “Clockwork Orange” on him.</p>
</div></div><!-- .post-main.post-comment--><!--  include _partial/comments.pug--></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>