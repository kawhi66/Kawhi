<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>对比 Webpack 和 Rollup | Kawhi's blogs</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/todo">Todo</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/前端工程化/">前端工程化</a></div><div class="post-time">2019-05-15</div></div></div><div class="container post-header"><h1>对比 Webpack 和 Rollup</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">目录</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#配置文件的对比"><span class="toc-number">1.</span> <span class="toc-text">配置文件的对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#打包结果的对比"><span class="toc-number">2.</span> <span class="toc-text">打包结果的对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#特性对比"><span class="toc-number">3.</span> <span class="toc-text">特性对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack-的优势"><span class="toc-number">3.1.</span> <span class="toc-text">Webpack 的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rollup-的优势"><span class="toc-number">3.2.</span> <span class="toc-text">Rollup 的优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用场景对比"><span class="toc-number">4.</span> <span class="toc-text">使用场景对比</span></a></li></ol></details></div><div class="container post-content"><p>工作当中用到最多的是 Webpack，事实上，由于种种原因，对公司内部大多数 Web 项目来说，Webpack 几乎是唯一的选择。<a href="https://www.npmjs.com/package/next-wrapper" target="_blank" rel="noopener">next-wrapper</a> 的最终输出物是一个 JavaScript 库，我试图使它在 Node 环境和浏览器环境下都可以使用，我最初尝试用 Webpack 打包，但打出的包在 Node 环境下无法运行。Rollup 很好的解决了我的问题，通过 Rollup 可以轻松地打出支持不同模块规范的包。在大多数涉及到 Webpack 和 Rollup 的讨论中，<em>Use webpack for apps, and Rollup for libraries</em> 成为了众多开发者的共识，本文对 Webpack 和 Rollup 的特点和使用场景做了较深入的分析对比，以便更好的理解和应用这两个模块打包工具。</p>
<p><em>注：本文涉及到的 Webpack 和 Rollup 均为当前的最新版，即 Webpack V4.31.0 和 Rollup V1.12.0。</em></p>
<h1 id="配置文件的对比"><a href="#配置文件的对比" class="headerlink" title="配置文件的对比"></a>配置文件的对比</h1><p>在测试项目中，我试图通过 Webpack 和 Rollup 分别将名为 <code>test-build.js</code> 的一个简单的模块文件打包到 <code>test-build</code> 目录下，它以 ES 模块规范导出了一个固定值，并且打包结果应该支持实现 CommonJS 规范的运行环境（这里特指 Node 环境）。<code>test-build.js</code> 内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>Rollup 的配置文件 <code>rollup.config.js</code> 内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    input: <span class="string">'test-build.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        file: <span class="string">'test-build/rollup.js'</span>,</span><br><span class="line">        format: <span class="string">'cjs'</span>,</span><br><span class="line">        name: <span class="string">'testBuild'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Webpack 的配置文件 <code>webpack.config.js</code> 内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    entry: <span class="string">'./test-build.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'webpack.js'</span>,</span><br><span class="line">        library: <span class="string">'testBuild'</span>,</span><br><span class="line">        libraryTarget: <span class="string">'commonjs'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'test-build'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，对 JavaScript 库的构建和打包，从配置文件来看，两者差别不大。只是：</p>
<ul>
<li>由于 Rollup 对 ES 模块规范的支持，以 ES 模块规范定义的配置文件也可以完美的解析和运行。反之，尽管 Webpack 可以支持 <code>export default 100</code> 这种 ES 规范的模块导出方式，但如果配置文件也使用 ES 模块规范的导出方式则会在打包时报语法错误 <code>SyntaxError: Unexpected token export</code>。</li>
<li>Rollup 支持 <code>test-build/rollup.js</code> 这种<strong>相对路径</strong>的 <code>file</code> 定义方式，而 Webpack 推荐（只支持）以<strong>绝对路径</strong>来定义 <code>path</code> 打包路径。</li>
</ul>
<h1 id="打包结果的对比"><a href="#打包结果的对比" class="headerlink" title="打包结果的对比"></a>打包结果的对比</h1><p>Rollup 的打包结果与源码差别不大，事实上，即便源码内容再复杂，打包结果与源码的差别也非常类似。Rollup 的打包结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testBuild = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = testBuild;</span><br></pre></td></tr></table></figure>
<p>而 Webpack 的打包结果与源码的差别就比较大了，限于篇幅，这里只摘取了一段（未摘出的部分其实是 <code>__webpack_require__</code> 方法的实现），结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***/</span> <span class="string">"./test-build.js"</span>:</span><br><span class="line"><span class="comment">/*!***********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./test-build.js ***!</span></span><br><span class="line"><span class="comment">  \***********************/</span></span><br><span class="line"><span class="comment">/*! exports provided: default */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (100);\n\n\n//# sourceURL=webpack://testBuild/./test-build.js?"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>总体上来讲，Rollup 的打包结果无论从可读性，还是文件体积都有明显的优势。有<a href="http://www.ayqy.net/blog/%E4%BB%8Ewebpack%E5%88%B0rollup/" target="_blank" rel="noopener">文章</a>还指出，<code>__webpack_require__</code> 在执行时效率不高，因而就打包结果来说，Rollup 的处理要更好一些。</p>
<h1 id="特性对比"><a href="#特性对比" class="headerlink" title="特性对比"></a>特性对比</h1><p>·<br>Webpack 和 Rollup 两者的历史渊源，我没有深究，不过早在两年前（2017 年）就有<a href="http://www.ayqy.net/blog/%E4%BB%8Ewebpack%E5%88%B0rollup/" target="_blank" rel="noopener">文章</a>提出要放弃 Webpack。关于两者的特性对比，我还没有想到好的方法去做实践对比，如果要完全搞清楚，也许要深入到源码层面。我看过的关于两者对比的文章（<a href="https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c" target="_blank" rel="noopener">Webpack and Rollup: the same but different</a>（这篇文章是由 Rollup 的作者 <a href="https://medium.com/@Rich_Harris?source=user_popover" target="_blank" rel="noopener">Rich Harris</a> 本人写的），<a href="https://medium.com/jsdownunder/rollup-vs-webpack-javascript-bundling-in-2018-b35758a2268" target="_blank" rel="noopener">Rollup vs Webpack</a>，<a href="https://blog.csdn.net/wangyiyungw/article/details/84955909" target="_blank" rel="noopener">Webpack vs Rollup</a>（这是国内的开发者写的一篇文章））观点基本是一致的：</p>
<h2 id="Webpack-的优势"><a href="#Webpack-的优势" class="headerlink" title="Webpack 的优势"></a>Webpack 的优势</h2><ul>
<li>代码分块（Code-splitting）</li>
<li>静态资源（Static assets）</li>
<li>模块热更新（Hot module replacement）</li>
<li>插件和生态圈（Plugins and ecosystem）</li>
</ul>
<h2 id="Rollup-的优势"><a href="#Rollup-的优势" class="headerlink" title="Rollup 的优势"></a>Rollup 的优势</h2><ul>
<li>代码优化（Tree shaking / live code inclusion / dead code elimination）</li>
<li>ES 模块规范的原生支持和丰富的模块规范支持（ESNext native support and more）</li>
<li>简介的 API （Simple API）</li>
</ul>
<h1 id="使用场景对比"><a href="#使用场景对比" class="headerlink" title="使用场景对比"></a>使用场景对比</h1><blockquote>
<p>Use webpack for apps, and Rollup for libraries</p>
</blockquote>
<p>Rollup 的作者 <a href="https://medium.com/@Rich_Harris?source=user_popover" target="_blank" rel="noopener">Rich Harris</a> 在 2017 年的文章 <a href="https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c" target="_blank" rel="noopener">Webpack and Rollup: the same but different</a> 中提到了这个观点，它几乎成为了众多开发者公认的最佳应用实践，很多主流的 JavaScript 库也都在这么用。</p>
<p>需要注意的是，这并不是一个绝对的规则，<a href="https://medium.com/@Rich_Harris?source=user_popover" target="_blank" rel="noopener">Rich Harris</a> 是这么说的：</p>
<blockquote>
<p>If you need code-splitting, or you have lots of static assets, or you’re building something with lots of CommonJS dependencies, Webpack is a better choice. If your codebase is ES2015 modules and you’re making something to be used by other people, you probably want Rollup.</p>
</blockquote>
<p>如果你需要代码分块，或者有很多的静态资源，又或者你正在构建的东西用到了大量的 CommonJS 规范的模块依赖，webpack 是一个更好的选择。如果你的代码符合 ES2015 模块规范，而且想要它可以被其他人使用，你也许应该选择 rollup。</p>
</div></div><!-- .post-main.post-comment--><!--  include _partial/comments.pug--></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>