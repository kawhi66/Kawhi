<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>条件请求和 HTTP/304 Not Modified | Kawhi's blogs</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/todo">Todo</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/HTTP/">HTTP</a></div><div class="post-time">2019-06-03</div></div></div><div class="container post-header"><h1>条件请求和 HTTP/304 Not Modified</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">目录</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#命中和未命中"><span class="toc-number">1.</span> <span class="toc-text">命中和未命中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#再验证"><span class="toc-number">2.</span> <span class="toc-text">再验证</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#条件首部"><span class="toc-number">3.</span> <span class="toc-text">条件首部</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><p><strong>条件请求</strong>是客户端缓存<strong>再验证</strong>的检测机制，通过 HTTP 请求中特定的首部字段实现，这些首部字段规定了请求的前置条件，响应结果会因特定首部的值的不同而发生变化。<strong>缓存再验证命中</strong>时，服务器将返回 <strong>HTTP/304 Not Modified</strong> 响应。</p>
<h1 id="命中和未命中"><a href="#命中和未命中" class="headerlink" title="命中和未命中"></a>命中和未命中</h1><p>缓存无法保存世界上每份文档的副本，即便可以有些文档也可能会经常发生变化。到达缓存的请求，如果缓存中有副本可以为其提供服务，这被称为<strong>缓存命中（Cache Hit）</strong>。其他一些到达到达缓存的请求可能会由于 没有副本可用，而被转发给原始服务器，这被称为<strong>缓存未命中（Cache Miss）</strong>。</p>
<p><img src="/2019/06/03/HTTP-304/cache.jpeg" alt=""></p>
<p><strong>缓存命中率（Cache Hit Rate，也叫缓存命中比例）</strong>和<strong>字节命中率（Byte Hit Rate）</strong>可以用来对缓存性能进行评估，前者指的是由缓存提供服务的请求所占的比例，后者指的是缓存提供的字节在传输的所有字节中所占的比例。</p>
<p>缓存命中率有时也被称为<strong>文档命中率</strong>，它是基于文档的比例模型，由于文档并不完全是同一尺寸的，所以文档命中率并不能说明一切。以字节命中率作为度量值可以得知节省流量的程度，这对节省带宽很有利。文档命中率说明缓存阻止了多少通往外部网络的 Web 事务，字节命中率说明缓存阻止了多少字节传向因特网。</p>
<h1 id="再验证"><a href="#再验证" class="headerlink" title="再验证"></a>再验证</h1><p>缓存要不时地对其进行检测，看他们保存的副本是否仍是服务器上最新的副本，这些“新鲜度检测”被称为 <strong>HTTP 再验证（Cache Revalidation）</strong>。理论上，缓存可以在任意时刻，以任意的频率对副本进行再验证。但由于网络带宽限制，大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行再验证。</p>
<center><img src="/2019/06/03/HTTP-304/304.png" alt=""></center>

<p>缓存再验证可能有 3 种情况：</p>
<ul>
<li><p><strong>再验证命中（Revalidate Hit）或缓慢命中（Slow Hit）</strong><br>如果服务器对象未被修改，服务器会向客户端发送一个小（大概有 200 字节）的 <strong>HTTP/304 Not Modified</strong> 响应。</p>
</li>
<li><p><strong>再验证未命中</strong><br>如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的 HTTP/200 OK 响应。</p>
</li>
<li><p><strong>对象被删除</strong><br>如果服务器对象已经被删除了，服务器就会返回一个 HTTP/404 Not Found 响应，缓存也会将其副本删除。</p>
</li>
</ul>
<h1 id="条件首部"><a href="#条件首部" class="headerlink" title="条件首部"></a>条件首部</h1><p>HTTP 定义了 5 个条件首部（它们都是以 If- 开头），分别为：<code>If-Match</code>，<code>If-None-Match</code>，<code>If-Modified-Since</code>，<code>If-Unmodified-Since</code>，<code>If-Range</code>。对缓存再验证来说最有用的是 <code>If-Modified-Since</code> 和 <code>If-None-Match</code>。</p>
<center><img src="/2019/06/03/HTTP-304/headers.png" alt=""></center>

<p><code>If-Modified-Since</code> 首部可以与 <code>Last-Modified</code> 响应首部配合工作。缓存再验证时，条件请求会包含一个 <code>If-Modified-Since</code> 首部，其中携带有最后修改已缓存副本的日期：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: &lt;cached last-modified date&gt;</span><br></pre></td></tr></table></figure>
<p>有些时候，仅使用 <code>If-Modified-Since</code> 是不够的。HTTP 允许用户对被称为<strong>实体标签（ETag）</strong>的“版本标识符”进行比较。实体标签是附加到文档上的任意标签，它们可能包含文档的序列号或版本名，或者是文档内容的校验或其他指纹信息。当发布者对文档进行修改时，可以同步修改文档的实体标签来说明这个新的版本。这样，缓存就可以利用 <code>If-None-Match</code> 条件首部对缓存进行再验证。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: <span class="string">"&lt;etag_value&gt;"</span></span><br><span class="line">If-None-Match: <span class="string">"&lt;etag_value&gt;"</span>, <span class="string">"&lt;etag_value&gt;"</span>, …</span><br><span class="line">If-None-Match: *</span><br></pre></td></tr></table></figure>
<p>除非 HTTP 原始服务器无法生成实体标签验证器，否则就应该发送一个出去。如果 HTTP 缓存或服务器收到的请求既带有 <code>If-Modified-Since</code>，又带有实体标签条件首部（<code>If-None-Match</code>），那么只有这两个条件都满足时，才能返回 HTTP/304 Not Modified 响应。如果服务器回送了一个实体标签（ETag），HTTP 客户端就必须使用实体标签验证器。如果服务器只回送了一个 <code>Last-Modified</code> 值，客户端就可以使用 <code>If-Modified-Since</code> 验证。这样 <a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">HTTP/1.0</a> 和 <a href="https://tools.ietf.org/html/rfc2068" target="_blank" rel="noopener">HTTP/1.1</a> 缓存就都可以正确响应了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从 1997 年初发布至今，<a href="https://tools.ietf.org/html/rfc2068" target="_blank" rel="noopener">HTTP/1.1</a> 已经使用超过 20 年了，而且仍然在广泛使用。原发布文档超过了 160 页，先后又经过多次修订，本文只是冰山一角。</p>
</div></div><!-- .post-main.post-comment--><!--  include _partial/comments.pug--></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>