<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>This 的指向 | Kawhi's blogs</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/todo">Todo</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/ES6/">ES6</a></div><div class="post-time">2019-04-28</div></div></div><div class="container post-header"><h1>This 的指向</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">目录</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不同的执行环境"><span class="toc-number">2.</span> <span class="toc-text">不同的执行环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不同的场景"><span class="toc-number">3.</span> <span class="toc-text">不同的场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#疑问"><span class="toc-number">4.</span> <span class="toc-text">疑问</span></a></li></ol></details></div><div class="container post-content"><p>以前总觉得 <em>this</em> 应该和作用域链有关系，在应对类似的问题时，总是不由自主地从作用域链去分析。事实上，作用域链和 <em>this</em> 的指向没有半毛钱关系。原因很简单，对一个函数而言，它的作用域链早在函数声明的时候就决定了，而 <em>this</em> 的指向要到运行期才能决定。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在 <a href="https://github.com/kawhi66/scope-and-this-in-js" target="_blank" rel="noopener">scope-and-this-in-js</a> 中，我尽可能地列举了不同的 JavaScript 环境（浏览器环境和 Node 环境）和不同的应用场景下，<em>this</em> 这个特殊的引用的指向。很难用一句话准确的概括所有的场景，但最接近的可以是：在全局环境中，<em>this</em> 总是指向顶层对象；而函数中的 <em>this</em> 往往指向的是该函数的调用对象。</p>
<h1 id="不同的执行环境"><a href="#不同的执行环境" class="headerlink" title="不同的执行环境"></a>不同的执行环境</h1><p>浏览器环境和 Node 环境一个很重要的差别就是<a href="http://es6.ruanyifeng.com/#docs/let#顶层对象的属性" target="_blank" rel="noopener">顶层对象</a>的不同。在实际的测试过程中发现，事实也确是如此。在 <em>this</em> 指向顶层对象的场景中，对浏览器环境而言就是 window，在 Node 环境中则是 global。</p>
<h1 id="不同的场景"><a href="#不同的场景" class="headerlink" title="不同的场景"></a>不同的场景</h1><p>我主要列举了以下几种场景：</p>
<ul>
<li>函数定义在全局环境中，并且在全局环境中执行</li>
<li>函数定义在局部作用域内（定义在闭包或者引用类型变量中），在全局环境中执行</li>
<li>基于类生成的实例对象（类分别由构造函数和 Class 关键字定义）</li>
</ul>
<p>大部分场景下的表现是符合预期的，但有一种场景很特殊：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define in prototype of an ES6 class, assign to variable, and called in global context</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.user = <span class="string">'kawhi'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getUser() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.user</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn() &#123;</span><br><span class="line">        <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">return</span> _this</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="keyword">const</span> fn = instance.fn</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<p>这种场景下的 <em>this</em>，无论是浏览器环境或 Node 环境都是 <em>undefined</em>。对比 Foo 的 ES5 实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define in prototype of an ES5 class, assign to a variable, and called in global context</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = <span class="string">'kawhi'</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getUser = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.user</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">return</span> _this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="keyword">const</span> fn = instance.fn</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<p>此时的 <em>this</em> 则符合预期，指向了当前环境的顶层对象。</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>我想这里只有一个解释，Class 关键字声明的类屏蔽了这种用法。如果要想彻底搞清楚这个问题，恐怕只能去分析 Class 的原生实现了，都说它只是个语法糖，想来不仅如此。</p>
</div></div><!-- .post-main.post-comment--><!--  include _partial/comments.pug--></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>