<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ECMAScript 2015(ES6)：异步编程 Promise 篇 | Kawhi's blogs</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/ES6/">ES6</a></div><div class="post-time">2018-07-19</div></div></div><div class="container post-header"><h1>ECMAScript 2015(ES6)：异步编程 Promise 篇</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、单线程与异步"><span class="toc-number">1.</span> <span class="toc-text">一、单线程与异步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、ES5-中关于异步编程的解决方案"><span class="toc-number">2.</span> <span class="toc-text">二、ES5 中关于异步编程的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、setTimeout-方法"><span class="toc-number">2.1.</span> <span class="toc-text">1、setTimeout() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、callback-回调函数"><span class="toc-number">2.2.</span> <span class="toc-text">2、callback 回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、事件监听"><span class="toc-number">2.3.</span> <span class="toc-text">3、事件监听</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、发布-订阅"><span class="toc-number">2.4.</span> <span class="toc-text">4、发布/订阅</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、Promise"><span class="toc-number">3.</span> <span class="toc-text">三、Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、概览"><span class="toc-number">3.1.</span> <span class="toc-text">1、概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、基本用法"><span class="toc-number">3.2.</span> <span class="toc-text">2、基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型方法"><span class="toc-number">3.3.</span> <span class="toc-text">原型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延伸"><span class="toc-number">3.4.</span> <span class="toc-text">延伸</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></details></div><div class="container post-content"><p>未完待续。。。</p>
<h1 id="一、单线程与异步"><a href="#一、单线程与异步" class="headerlink" title="一、单线程与异步"></a>一、单线程与异步</h1><ul>
<li><a href="https://www.zhihu.com/question/20866267" target="_blank" rel="noopener">JavaScript 既是单线程又是异步的，请问这二者是否冲突，以及有什么区别？</a></li>
<li><a href="https://segmentfault.com/q/1010000004266993/" target="_blank" rel="noopener">JavaScript既然是单线程的，那么异步要怎么理解？</a></li>
<li><a href="http://blog.csdn.net/baidu_24024601/article/details/51861792" target="_blank" rel="noopener">为什么javascript是单线程？</a></li>
</ul>
<h1 id="二、ES5-中关于异步编程的解决方案"><a href="#二、ES5-中关于异步编程的解决方案" class="headerlink" title="二、ES5 中关于异步编程的解决方案"></a>二、ES5 中关于异步编程的解决方案</h1><p>为了避免由于脚本执行造成的阻塞引起的浏览器<strong>“假死”</strong>现象带来的糟糕的用户体验，我们需要在 Js 脚本中合理的使用异步进行优化。我们可以有很多的选择，各自有各自的适用场景，我会试着把它们都列出来作为一个总结。在 ES6 之前，大概有这几种方式：</p>
<h2 id="1、setTimeout-方法"><a href="#1、setTimeout-方法" class="headerlink" title="1、setTimeout() 方法"></a>1、setTimeout() 方法</h2><p>这是一个并不简单的方法。关于它的用法可以延伸出很多东西来，不过这里不会展开，以后的文章中可能会记录。有一篇文章可做参考：<a href="https://segmentfault.com/a/1190000003982302" target="_blank" rel="noopener">你真会用setTimeout吗?</a>。关于 <code>setTimeout(code, delay)</code> 的第二个参数 <code>delay</code> 定义的延迟执行的时间并不总是那么准确，在《深入浅出Nodejs》是这样说的：</p>
<blockquote>
<p>setTimeout 的主要问题在于，它并非那么精确。譬如通过 setTimeout() 设定一个任务在10毫秒后执行，但是在9毫秒之后，有一个任务占用了5毫秒的 CPU 时间片，再次轮到定时器执行时，时间就已经过期4毫秒。</p>
</blockquote>
<h2 id="2、callback-回调函数"><a href="#2、callback-回调函数" class="headerlink" title="2、callback 回调函数"></a>2、callback 回调函数</h2><p>和 <code>setTimeout()</code> 方法一样，这应该是异步编程最基本的方法之一。即定义函数的参数为一个 callback 回调函数，在函数内部定义 callback 的执行时机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">callback</span></span>()&#123;</span><br><span class="line">    // 回调函数...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> foo(callback) &#123;</span><br><span class="line">    // 在foo函数内部定义callback在1秒后执行</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(callback)</span><br></pre></td></tr></table></figure>
<p>当我们的代码逻辑并不那么复杂的时候，这种方法的优点就会体现出来。不过，随着代码复杂度的增加，回调函数会变的高度耦合，难以维护和管理。</p>
<h2 id="3、事件监听"><a href="#3、事件监听" class="headerlink" title="3、事件监听"></a>3、事件监听</h2><p>Js 采用事件驱动的机制来响应用户操作，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。假如我们给 <code>id</code> 为 <code>bar</code> 的元素绑定单击事件，执行方法 <code>foo</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// jQuery 事件绑定</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span> () &#123;</span><br><span class="line">    // 事件处理...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#id"</span>).on(<span class="string">'click'</span>, foo)</span><br></pre></td></tr></table></figure>
<p>这种方法也很容易理解，在很长的一段时间内我都在使用它。同样当代码逻辑变得复杂起来时，这种事件绑定就会变得低效、不太灵活。当整个应用都以事件驱动时，运行流程就会变得非常混乱，很不清晰。</p>
<h2 id="4、发布-订阅"><a href="#4、发布-订阅" class="headerlink" title="4、发布/订阅"></a>4、发布/订阅</h2><p>对事件监听做延伸，可以引出异步编程的另外一种强大的模式，即<strong>“发布/订阅模式（publish-subscribe pattern）”</strong>，又称<strong>“观察者模式（observer pattern）”</strong>，这里有一篇参考文章：<a href="http://blog.csdn.net/q1056843325/article/details/53353850" target="_blank" rel="noopener">浅析JavaScript设计模式——发布-订阅/观察者模式</a>。这种模式虚拟一个<strong>“信号中心”</strong>，某个任务执行完成，就向信号中心<strong>“发布（publish）”</strong>一个信号，其他任务可以向信号中心<strong>“订阅（subscribe）”</strong>这个信号，从而知道什么时候自己可以开始执行。下面是一个例子（来自<a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="noopener">Javascript异步编程的4种方法</a>）:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 发布/订阅模式的一种实现</span></span><br><span class="line"><span class="comment">## 来自 Ben Alman 的 [Tiny Pub/Sub](https://github.com/cowboy/jquery-tiny-pubsub)</span></span><br><span class="line"></span><br><span class="line">// f2 向 <span class="string">"信号中心"</span> jQuery 订阅 <span class="string">"done"</span> 信号</span><br><span class="line">jQuery.subscribe(<span class="string">"done"</span>, f2);</span><br><span class="line"></span><br><span class="line">// f1 向 <span class="string">"信号中心"</span> jQuery 发布 <span class="string">"done"</span> 信号</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f1</span></span>() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        jQuery.publish(<span class="string">"done"</span>); // <span class="string">"done"</span> 信号发布后，f2 即开始执行</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// f2 取消订阅（unsubscribe）</span><br><span class="line">jQuery.unsubscribe(<span class="string">"done"</span>, f2);</span><br></pre></td></tr></table></figure>
<p>这种模式下，“消息中心”（上例中是 <code>jQuery</code> ）完成信号的接收和分发，函数间不发生直接联系。通过查看“消息中心”，我们可以了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<p>在 ES6 以后（包括 ES6 ），我们有了更多的选择，比如 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise</a>。准确的说，Promise 并不是 ES6 新的语言特性，它早在 ES6 之前就由社区提出并实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。本文接下来的部分会针对 Promise 做重点介绍，除了 Promise，ES6 还提供了异步编程的另一种解决方案 <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator</a> 函数，ES7 标准还引入了 <a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">async</a> 函数，关于后面两种方法的研究和介绍会在之后的文章中展开。</p>
<h1 id="三、Promise"><a href="#三、Promise" class="headerlink" title="三、Promise"></a>三、Promise</h1><p>之前说过了，严格来说 Promise 并不是 ES6 新的语言特性，它早在 ES6 之前就由社区提出并实现了。在 JavaScript 的世界里，最早得到广泛使用的 Promise 是 jQuery 的 AJAX 模块中出现的 <code>jQuery.Deferred()</code>。<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a> 标准规定了一系列 API，并配有大量的测试用例，ES6 直接整合了这个标准。Promise 的出现是为了更好的处理 JavaScript 异步回调中无法避免的多层嵌套（Callback Hell，回调地狱）现象。在 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+</a> 规范中有如下规定：</p>
<ul>
<li>Promise 对象有且只有三种状态，Pending：Promise 对象的初始状态，在任务执行完成前将始终保持这个状态；Fulfilled：任务成功执行完成的状态；Rejected：任务执行完成但执行失败的状态；</li>
<li>Promise 的状态只可能从 Pending 状态转到 Fulfilled 状态或者是由 pending 状态转为 Rejected 状态，而且不能逆向转换，同时 Fulfilled 状态和 Rejected 状态也不能相互转换；</li>
<li>Promise 对象必须实现 then 方法，then 是 promise 规范的核心，而且 then 方法也必须返回一个 Promise 对象，同一个 Promise 对象可以注册多个 then 方法，并且回调的执行顺序跟它们的注册顺序一致；</li>
<li>then 方法接受两个回调函数，它们分别为成功时的回调和失败时的回调，并且它们分别在：Promise 由 Pending 状态转换到 Fulfilled 状态时被调用和 Promise 由 Pending 状态转换到 Rejected 状态时被调用。</li>
</ul>
<h2 id="1、概览"><a href="#1、概览" class="headerlink" title="1、概览"></a>1、概览</h2><p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。<br>Promise 也有一些缺点。首先，无法取消 Promise，<strong>一旦新建它就会立即执行</strong>，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h2 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h2><p>ES6 规定，Promise 对象是一个构造函数，可以用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 ES6 原生提供，不用自己实现。</p>
<p>其中，resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个 Promise 实例</span><br><span class="line">const p = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 一个 Promise 对象的简单例子</span><br><span class="line"><span class="keyword">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // setTimeout 的第三个参数及其以后的参数都会作为参数传递给 resolve 函数</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100).<span class="keyword">then</span>((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Promise 实例新建后就会立即执行</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> p = new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  // Promise 实例 p 新建后就会立即执行</span><br><span class="line">  // “Promise” 会先打印出来</span><br><span class="line">  console.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  // <span class="keyword">then</span> 方法指定的回调函数，将在**当前脚本所有同步任务执行完**才会执行</span><br><span class="line">  // “resolved.” 会最后打印出来</span><br><span class="line">  console.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line">// Promise</span><br><span class="line">// Hi!</span><br><span class="line">// resolved</span><br></pre></td></tr></table></figure>
<p>如果调用 resolve 函数和 reject 函数时带有参数，那么它们的参数会被传递给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const p2 = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意，这时 p1 的状态就会传递给 p2，也就是说，p1 的状态决定了 p2 的状态。如果 p1 的状态是 pending，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 resolved 或者 rejected，那么 p2 的回调函数将会立刻执行。</p>
<p>注意，<strong>调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;).<span class="keyword">then</span>(r =&gt; &#123;</span><br><span class="line">  console.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 方法里面，而不应该直接写在 resolve 或 reject 的后面。所以，最好在它们前面加上 return 语句，这样就不会有意外。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> resolve(1);</span><br><span class="line">  // 后面的语句不会执行</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>