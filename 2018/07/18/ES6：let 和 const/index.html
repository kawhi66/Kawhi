<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ES6：let 和 const | Kawhi's blogs</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/ES6/">ES6</a></div><div class="post-time">2018-07-18</div></div></div><div class="container post-header"><h1>ES6：let 和 const</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">目录</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1、变量提升"><span class="toc-number">1.</span> <span class="toc-text">1、变量提升</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2、变量重复定义"><span class="toc-number">2.</span> <span class="toc-text">2、变量重复定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、变量作用域"><span class="toc-number">3.</span> <span class="toc-text">3、变量作用域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4、const-命令"><span class="toc-number">4.</span> <span class="toc-text">4、const 命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5、关于顶层对象的讨论"><span class="toc-number">5.</span> <span class="toc-text">5、关于顶层对象的讨论</span></a></li></ol></details></div><div class="container post-content"><p>let or const or var</p>
<p>本文要学习和讨论的是 ES6 新增的两个变量声明的关键字 let 和 const。在 ES5 中，我们一般使用 var 关键字来声明变量：<code>var test = 1, test1 = &quot;kawhi&quot;;</code>，这种声明方式会给我们带来一些麻烦，具体来看一下：</p>
<h1 id="1、变量提升"><a href="#1、变量提升" class="headerlink" title="1、变量提升"></a>1、变量提升</h1><blockquote>
<p>在 ES5 中，以 var 关键字声明的函数和变量总是会被 JavaScript 解释器隐式地提升(hoist)到<strong>包含他们的作用域的最顶端</strong>。</p>
</blockquote>
<p>当发生变量提升的时候，在代码中通过 var 关键字声明的变量在<strong>从其作用域开始到声明之前</strong>都是可以被使用的，不过值为 undefined。看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># var关键字带来的变量提升</span></span><br><span class="line">console.log(foo); // 输出 undefined</span><br><span class="line">var foo = 0;</span><br></pre></td></tr></table></figure>
<p>let 改变了这种语法行为，使用 let 关键字在变量声明之前它是不存在的，这时候调用会发生错误，抛出异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用let声明变量不会有变量提升</span></span><br><span class="line">console.log(bar); // ReferenceError: bar is not defined</span><br><span class="line"><span class="built_in">let</span> bar = 0;</span><br></pre></td></tr></table></figure>
<p>let 关键字声明变量的这种特性可以引出一个概念：<strong>暂时性死区（temporal dead zone，简称 TDZ）</strong>。在上述代码中，对变量 foo 而言，从作用域开始到 foo 变量被声明这段区域都可以称为变量 foo 的死区，代码运行到这个阶段时，foo 变量是不可被使用的。补充两个例子（来自 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门</a>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo 1</span></span><br><span class="line">var tmp = 123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  // 虽然存在全局变量 tmp，但是块级作用域内 <span class="built_in">let</span> 又声明了一个局部变量 tmp，导致后者绑定这个块级作用域，所以在 <span class="built_in">let</span> 声明变量前，对 tmp 赋值会报错</span><br><span class="line">  tmp = <span class="string">'abc'</span>; // ReferenceError: tmp is not defined</span><br><span class="line">  <span class="built_in">let</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo 2</span></span><br><span class="line"><span class="comment"># 使用 let 声明变量时，只要变量在还没有声明完成前使用，就会报错。</span></span><br><span class="line">var x = x;</span><br><span class="line"><span class="built_in">let</span> x = x; // SyntaxError: Identifier <span class="string">'x'</span> has already been declared</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
</blockquote>
<h1 id="2、变量重复定义"><a href="#2、变量重复定义" class="headerlink" title="2、变量重复定义"></a>2、变量重复定义</h1><p>在 ES5 中，使用 var 语句重复声明变量是合法且无害的，如果你试图读取一个没有声明的变量，Js 会报错，在 ES5 的严格模式下，给一个没有声明的变量赋值也会报错，但在非严格模式下，给一个未声明的变量赋值，Js 实际上会给全局对象创建一个同名的属性，并且工作起来像一个正确声明的全局变量。这意味着你可以侥幸不声明全局变量，但这是一个非常不好的习惯并且会造成很多 bug。<strong>在 ES6 中，使用 let 声明的变量不允许在相同作用域内，重复声明同一个变量。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo1</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> a = 10;</span><br><span class="line">    var a = 1; // SyntaxError: Identifier <span class="string">'a'</span> has already been declared</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo 2</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> a = 10;</span><br><span class="line">    <span class="built_in">let</span> a = 1; // SyntaxError: Identifier <span class="string">'a'</span> has already been declared</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo 3 在函数内部重新声明参数会报错</span></span><br><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">    <span class="built_in">let</span> arg; // SyntaxError: Identifier <span class="string">'arg'</span> has already been declared</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo 4</span></span><br><span class="line"><span class="keyword">function</span> func(arg) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">let</span> arg; // 不会报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<h1 id="3、变量作用域"><a href="#3、变量作用域" class="headerlink" title="3、变量作用域"></a>3、变量作用域</h1><blockquote>
<p>JavaScript 是基于词法作用域的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。全局变量在程序内始终是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数体内始终是有定义的。</p>
</blockquote>
<p>这是 ES5 中对于变量作用域的一个简单描述。在一些类似 C 语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明他们的代码段之外是不可见的，我们称为<strong>块级作用域（block scope）</strong>。在 ES5 中没有块级作用域，取而代之使用了<strong>函数作用域（function scope）</strong>，在 ES6 中，let 实际上为 JavaScript 新增了块级作用域。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo 1 外层作用域无法读取内层作用域的变量</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; &#123; <span class="built_in">let</span> insane = <span class="string">'Hello World'</span> &#125;</span><br><span class="line">                console.log(insane); // ReferenceError: insane is not defined</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo 2 外层代码块不受内层代码块的影响</span></span><br><span class="line"><span class="comment"># 如果两次都使用var定义变量n，最后输出的值才是10</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> n = 5;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">let</span> n = 10</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(n) // 5</span><br><span class="line">&#125;;</span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo 3 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</span></span><br><span class="line">// IIFE 写法</span><br><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var tmp = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">// 块级作用域写法</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">let</span> tmp = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>JavaScript 中的函数总是运行在他们被定义的作用域里，而不是他们被执行的作用域里。</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>() &#123;</span><br><span class="line">    console.log(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">    var x = 5;</span><br><span class="line">    a()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b() // 10</span><br></pre></td></tr></table></figure>
<p>作用域是 JavaScript 中比较重要的一个概念，很多 Js 部分的面试题都会围绕作用域展开，比如最常见的一个，<strong>作用域链（scope chain）</strong>。每一段 Js 代码（全局代码或函数）都有一个与之关联的作用域链，这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“<strong>作用域中</strong>”的变量。在这里面，函数比较特殊，首先明确一点，<strong>在 Js 里面，函数也是对象，</strong>而且和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是 <code>[[Scope]]</code>，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>对作用域链的理解是一个重点也是一个难点，在本文中很难尽述，关于作用域链还会涉及到其他一些知识点的理解，比如 with 语句修改作用域链和闭包的使用，关于这部分我会重新写一篇文章进行分析。上述就是在 ES5 中进行变量声明可能会遇到的一些麻烦以及 ES6 中做的相应处理，接下来我们看看 ES6 中还提供了哪些关于变量的新的特性。</p>
<h1 id="4、const-命令"><a href="#4、const-命令" class="headerlink" title="4、const 命令"></a>4、const 命令</h1><p>const 声明一个只读的常量，一旦声明（且声明时必须同时进行赋值），常量的值就不能改变。const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效；const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用；const 声明的常量，也与 let 一样不可重复声明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo 1</span></span><br><span class="line">const PI = 3.1415;</span><br><span class="line">PI = 3; // TypeError: Assignment to constant variable.</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo 2</span></span><br><span class="line">const foo // SyntaxError: Missing initializer <span class="keyword">in</span> const declaration</span><br></pre></td></tr></table></figure>
<blockquote>
<p>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</p>
</blockquote>
<p>我们知道，<strong>JavaScript 中的数据类型分为两类：原始类型（primitive type）和对象类型（object type）</strong>。对于包括数值、字符串和布尔值等在内的原始类型数据，值就保存在变量指向的那个内存地址里，因此等同于常量。但对于对象类型（也被称为复合类型）的数据（主要是对象和数组），变量所保存的是一个指向其内存地址的指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<h1 id="5、关于顶层对象的讨论"><a href="#5、关于顶层对象的讨论" class="headerlink" title="5、关于顶层对象的讨论"></a>5、关于顶层对象的讨论</h1><blockquote>
<p>ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。</p>
</blockquote>
<p>在浏览器 ES5 环境中，为了在不同的作用域内进行数据共享，我们经常会将共享的数据定义为全局变量或者定义为 window 对象的属性，在 ES5 中，这是完全等价的。关于顶层对象，在 ES5 中指的是 window 对象，在 Node 环境中指的是 global 对象。关于顶层对象的数据与全局变量等价，阮一峰在 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门</a> 提到了这种设计的一些问题。</p>
<blockquote>
<p>首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
</blockquote>
<p>关于顶层对象本身，在不同 Js 环境中表现也不一致。</p>
<ul>
<li>浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window；</li>
<li>浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self；</li>
<li>Node 里面，顶层对象是 global，但其他环境都不支持。</li>
</ul>
<p>在 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门</a> 中，阮一峰也给出了两种获取顶层对象<strong>勉强可用</strong>的方法和一个用来获取顶层对象的库 <a href="https://github.com/ljharb/System.global" target="_blank" rel="noopener">System.global</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line">(typeof window !== <span class="string">'undefined'</span> ?</span><br><span class="line">    window :</span><br><span class="line">    (typeof process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">        typeof require === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">        typeof global === <span class="string">'object'</span>) ?</span><br><span class="line">    global :</span><br><span class="line">    this);</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">var getGlobal = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof self !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> self; &#125;</span><br><span class="line">    <span class="keyword">if</span> (typeof window !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> window; &#125;</span><br><span class="line">    <span class="keyword">if</span> (typeof global !== <span class="string">'undefined'</span>) &#123; <span class="built_in">return</span> global; &#125;</span><br><span class="line">    throw new Error(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ES5 只有两种声明变量的方法：var 命令和 function 命令。ES6 除了添加 let 和 const 命令，另外两种声明变量的方法：import 命令和 class 命令，加上 var 命令和 function 命令，ES6 一共定义了六种声明变量的方法。关于 import 命令和 class 命令的学习，我会在之后的文章中记录下来。</p>
<p>最后，对本文的内容做一下回顾和梳理。在本文中，为了更好的理解 let 命令和 const 命令，我首先对 ES5 中使用 var 关键字声明变量所存在的问题进行了罗列，包括 var 命令所引起的<strong>变量提升、重复声明和作用域耦合</strong>等，同时，针对性的对 ES6 中的应对方式做了说明。接着，我介绍了 ES6 中新增的用于进行常量定义的 const 命令，然后对顶层对象在不同 Js 环境中的不同表现做了说明。在本文中，大量引用和借鉴了阮一峰先生在 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">ECMAScript 6 入门</a> 一书中的观点，同时结合 <em>JavaScript权威指南</em> 中的诸多内容和我自己的一些理解进行记录。正如我在文章开头所提到的，作为 Js 的基础知识，本文中的很多内容都有可能会在 Js 部分的面试题中出现，希望大家都可以掌握和理解。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>