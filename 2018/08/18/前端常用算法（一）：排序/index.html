<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>前端常用算法（一）：排序 | Kawhi's blogs</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/算法/">算法</a></div><div class="post-time">2018-08-18</div></div></div><div class="container post-header"><h1>前端常用算法（一）：排序</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1、插入排序（insertion-sort）"><span class="toc-number">1.</span> <span class="toc-text">1、插入排序（insertion-sort）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2、-选择排序（selection-sort）"><span class="toc-number">2.</span> <span class="toc-text">2、 选择排序（selection-sort）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、冒泡排序（bubble-sort）"><span class="toc-number">3.</span> <span class="toc-text">3、冒泡排序（bubble-sort）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4、快速排序（quick-sort）"><span class="toc-number">4.</span> <span class="toc-text">4、快速排序（quick-sort）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5、归并排序（merge-sort）"><span class="toc-number">5.</span> <span class="toc-text">5、归并排序（merge-sort）</span></a></li></ol></details></div><div class="container post-content"><p>数组排序算法 JavaScript 实现整理</p>
<p>一个直观的排序动画：<a href="http://math.hws.edu/eck/js/sorting/xSortLab.html" target="_blank" rel="noopener">xSortLab</a><br>wiki：<a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="noopener">Sorting_algorithm</a></p>
<h1 id="1、插入排序（insertion-sort）"><a href="#1、插入排序（insertion-sort）" class="headerlink" title="1、插入排序（insertion-sort）"></a>1、插入排序（insertion-sort）</h1><p>插入排序的基本操作是指将一个记录插入到已经排好序的有序表中，得到一个新的、记录数增1的有序表。排序过程大致如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序； </li>
<li>取出下一个元素，在已经排好序的元素序列中从后向前扫描； </li>
<li>如果该元素大于新元素，将该元素移到下一位置； </li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； </li>
<li>将新元素插入到该位置后； </li>
<li>重复步骤 2 ~ 5。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.insertionSort = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> cur_array = this,</span><br><span class="line">        cur_array_length = this.length,</span><br><span class="line">        cur_item, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = 1; i &lt; cur_array_length; i++) &#123;</span><br><span class="line">        cur_item = cur_array[i];</span><br><span class="line">        j = i - 1;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= 0 &amp;&amp; (cur_array[j] &gt; cur_item)) &#123;</span><br><span class="line">            cur_array[j + 1] = cur_array[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur_array[j + 1] = cur_item;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> cur_array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2、-选择排序（selection-sort）"><a href="#2、-选择排序（selection-sort）" class="headerlink" title="2、 选择排序（selection-sort）"></a>2、 选择排序（selection-sort）</h1><p>选择排序是一种简单直观的排序算法。选择排序就是通过 n-i 次关键字间的比较，从 n-i-1 个记录中选出关键字最小的记录，并和第 i 个记录进行交换。<br>它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.selectionSort = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> cur_array = this, cur_array_length = this.length;</span><br><span class="line">    <span class="built_in">let</span> cur_item, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; cur_array_length; i++) &#123;</span><br><span class="line">        cur_item = cur_array[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = i + 1; j &lt; cur_array_length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_array[j] &lt; cur_item) &#123;</span><br><span class="line">                <span class="built_in">let</span> temp = cur_item;</span><br><span class="line">                cur_item = cur_array[j];</span><br><span class="line">                cur_array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        cur_array[i] = cur_item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> cur_array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3、冒泡排序（bubble-sort）"><a href="#3、冒泡排序（bubble-sort）" class="headerlink" title="3、冒泡排序（bubble-sort）"></a>3、冒泡排序（bubble-sort）</h1><p>冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.bubbleSort = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> cur_array = this, cur_array_length = this.length;</span><br><span class="line">    <span class="built_in">let</span> i, j, n = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; cur_array_length - 1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = 0; j &lt; cur_array_length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_array[j] &lt; cur_array[j - 1]) &#123;</span><br><span class="line">                <span class="built_in">let</span> temp = cur_array[j];</span><br><span class="line">                cur_array[j] = cur_array[j - 1];</span><br><span class="line">                cur_array[j - 1] = temp;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; 1) <span class="built_in">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> cur_array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4、快速排序（quick-sort）"><a href="#4、快速排序（quick-sort）" class="headerlink" title="4、快速排序（quick-sort）"></a>4、快速排序（quick-sort）</h1><p>“快速排序”的排序过程只需要三步：</p>
<ul>
<li>在数据集之中，选择一个元素作为”基准”（pivot）；</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边；</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.quickSort = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    const cur_array = this;</span><br><span class="line">    const cur_array_length = this.length;</span><br><span class="line">    <span class="built_in">let</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_array.length &lt;= 1) &#123;</span><br><span class="line">        <span class="built_in">return</span> cur_array;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> pivotIndex = Math.floor(cur_array.length / 2);</span><br><span class="line">    <span class="built_in">let</span> pivot = cur_array.splice(pivotIndex, 1)[0];</span><br><span class="line">    <span class="built_in">let</span> left = [],</span><br><span class="line">        right = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; cur_array.length; i++) &#123;</span><br><span class="line">        (cur_array[i] &lt; pivot ? left : right).push(cur_array[i]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> left.quickSort().concat([pivot], right.quickSort());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5、归并排序（merge-sort）"><a href="#5、归并排序（merge-sort）" class="headerlink" title="5、归并排序（merge-sort）"></a>5、归并排序（merge-sort）</h1><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br>归并操作的过程如下：</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.mergeSort = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> cur_array = this, cur_array_length = this.length;</span><br><span class="line">    const merge = (left, right) =&gt; &#123;</span><br><span class="line">        <span class="built_in">let</span> temp_array = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">            temp_array.push((left[0] &lt; right[0] ? left : right).<span class="built_in">shift</span>())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> temp_array.concat(left, right);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur_array.length &lt;= 1) &#123;</span><br><span class="line">        <span class="built_in">return</span> cur_array;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> index = Math.floor(cur_array_length / 2);</span><br><span class="line">    <span class="built_in">let</span> left = cur_array.slice(0, index);</span><br><span class="line">    <span class="built_in">let</span> right = cur_array.slice(index);</span><br><span class="line">    <span class="built_in">return</span> merge(left.mergeSort(), right.mergeSort());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>