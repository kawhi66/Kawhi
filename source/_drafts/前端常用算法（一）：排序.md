---
title: 前端常用算法（一）：排序
date: 2018-08-18 10:34:01
---
数组排序算法 JavaScript 实现整理

一个直观的排序动画：[xSortLab](http://math.hws.edu/eck/js/sorting/xSortLab.html)
wiki：[Sorting_algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm)

# 1、插入排序（insertion-sort）

插入排序的基本操作是指将一个记录插入到已经排好序的有序表中，得到一个新的、记录数增1的有序表。排序过程大致如下：
- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排好序的元素序列中从后向前扫描；
- 如果该元素大于新元素，将该元素移到下一位置；
- 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤 2 ~ 5。

```bash
Array.prototype.insertionSort = function() {
    let cur_array = this,
        cur_array_length = this.length,
        cur_item, i, j;

    for (i = 1; i < cur_array_length; i++) {
        cur_item = cur_array[i];
        j = i - 1;
        while (j >= 0 && (cur_array[j] > cur_item)) {
            cur_array[j + 1] = cur_array[j];
            j--;
        }

        cur_array[j + 1] = cur_item;
    };

    return cur_array
}
```

# 2、 选择排序（selection-sort）

选择排序是一种简单直观的排序算法。选择排序就是通过 n-i 次关键字间的比较，从 n-i-1 个记录中选出关键字最小的记录，并和第 i 个记录进行交换。
它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

```bash
Array.prototype.selectionSort = function() {
    let cur_array = this, cur_array_length = this.length;
    let cur_item, i, j;

    for (i = 0; i < cur_array_length; i++) {
        cur_item = cur_array[i];

        for (j = i + 1; j < cur_array_length; j++) {
            if (cur_array[j] < cur_item) {
                let temp = cur_item;
                cur_item = cur_array[j];
                cur_array[j] = temp;
            }
        };

        cur_array[i] = cur_item;
    }

    return cur_array
}
```

# 3、冒泡排序（bubble-sort）

冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

```bash
Array.prototype.bubbleSort = function() {
    let cur_array = this, cur_array_length = this.length;
    let i, j, n = 0;

    for (i = 0; i < cur_array_length - 1; i++) {
        for (j = 0; j < cur_array_length - i; j++) {
            if (cur_array[j] < cur_array[j - 1]) {
                let temp = cur_array[j];
                cur_array[j] = cur_array[j - 1];
                cur_array[j - 1] = temp;
                n++;
            }

        };

        if (n < 1) break;
    };

    return cur_array;
}
```

# 4、快速排序（quick-sort）

"快速排序"的排序过程只需要三步：
- 在数据集之中，选择一个元素作为"基准"（pivot）；
- 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边；
- 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

```bash
Array.prototype.quickSort = function() {
    const cur_array = this;
    const cur_array_length = this.length;
    let i;

    if (cur_array.length <= 1) {
        return cur_array;
    };

    let pivotIndex = Math.floor(cur_array.length / 2);
    let pivot = cur_array.splice(pivotIndex, 1)[0];
    let left = [],
        right = [];

    for (i = 0; i < cur_array.length; i++) {
        (cur_array[i] < pivot ? left : right).push(cur_array[i]);
    };

    return left.quickSort().concat([pivot], right.quickSort());
};
```

# 5、归并排序（merge-sort）

归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
归并操作的过程如下：
- 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
- 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
- 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
- 重复步骤 3 直到某一指针达到序列尾；
- 将另一序列剩下的所有元素直接复制到合并序列尾。

```bash
Array.prototype.mergeSort = function() {
    let cur_array = this, cur_array_length = this.length;
    const merge = (left, right) => {
        let temp_array = [];

        while (left.length && right.length) {
            temp_array.push((left[0] < right[0] ? left : right).shift())
        }

        return temp_array.concat(left, right);
    };

    if (cur_array.length <= 1) {
        return cur_array;
    };

    let index = Math.floor(cur_array_length / 2);
    let left = cur_array.slice(0, index);
    let right = cur_array.slice(index);
    return merge(left.mergeSort(), right.mergeSort());
}
```
