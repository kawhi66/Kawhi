---
title: 异步任务串行执行
date: 2019-05-04 08:11:56
tags: ES6
---

JavaScript 应用在运行时具有**单线程**和**事件驱动**的特点。为了避免主线程的阻塞，在开发过程中应该合理设计异步事件的执行逻辑来提升产品的性能和用户体验，这是一件并不简单的事情。多个异步任务的执行场景无外乎是**并行**和**串行**两种，异步任务并行执行可以使用 `Promise.all(iterable)` 来实现，本文主要是介绍异步任务串行执行的一个解决方案 —— [next-wrapper](https://www.npmjs.com/package/next-wrapper)。

# 简介

我对 [next-wrapper](https://www.npmjs.com/package/next-wrapper) 的定位是一个异步任务包装器，通过调用 `nextWrapper(fn)` 方法暴露 `next` 方法给 `fn` 并执行这个异步任务，在异步任务内部合理的调用 `next()` 方法就可以执行下一个通过 `nextWrapper(fn)` 包装的异步任务。例如：

```JavaScript
const nextWrapper = require('next-wrapper')
nextWrapper(function (next) {
    setTimeout(() => {
        console.log('async-0')
        next()
    }, 200)
})
nextWrapper(function (next) {
    setTimeout(() => {
        console.log('async-1')
        next()
    }, 200)
})
nextWrapper(function (next) {
    setTimeout(() => {
        console.log('async-2') // 异步任务执行结束，不再调用 next()
    }, 200)
})
```

执行结果如下：

```JavaScript
async-0
async-1
async-2
```

# 事件中心

[next-wrapper](https://www.npmjs.com/package/next-wrapper) 的核心是一个[事件中心](https://github.com/kawhi66/next-wrapper)。事件中心用来管理异步任务队列，并调度各个异步任务按顺序执行和结束。核心部分源码如下：

```JavaScript
/**
 * @description manager center for async events
 * @property _state - running status
 * @property _idx - index of current running event
 * @property _queue - async events queue
 */
function EventCenter() {
    this._state = 0
    this._idx = 0
    this._queue = []
}

EventCenter.prototype.addEvents = function (fn) {
    const args = [].slice.call(arguments)
    const fnt = ({}).toString.call(fn).toLowerCase().split(" ")[1].slice(0, -1)
    let events = []
    if (args.length > 1) {
        args.forEach(item => {
            if (typeof item === 'function') {
                events.push(item)
            } else {
                events.push(noop)
            }
        })
    } else {
        if (fnt === 'function') {
            events.push(fn)
        } else if (fnt === 'array') {
            fn.forEach(item => {
                if (typeof item === 'function') {
                    events.push(item)
                } else {
                    events.push(noop)
                }
            })
        }
    }

    this._queue = this._queue.concat(events)
}

EventCenter.prototype.next = function () {
    if (this._queue.length <= this._idx + 1) {
        return false
    }

    if (typeof this._queue[++this._idx] === 'function') {
        this._queue[this._idx](this.next.bind(this))
    }
}
```

简单来说，每一次调用 `nextWrapper(fn)` 会执行 `addEvents(fn)` 将 `fn` 添加到异步任务队列 `_queue` 并将 `next` 方法暴露给 `fn`。异步任务在执行结束后调用 `next()` 方法可以启动队列中的下一个异步任务的执行，直到队列中的所有异步任务执行完毕。事实上，这也是典型的 [Express 中间件](https://stackoverflow.com/questions/7337572/what-does-middleware-and-app-use-actually-mean-in-expressjs)的实现方式。

# 唯一性

在实际的开发过程中，需要执行异步任务的场景可能有多个。比如说，某个业务单元需要执行一系列的异步任务，另一个业务单元呢也需要执行另外一系列的异步任务，如果都通过 `nextWrapper(fn)` 来注册异步任务，没办法区分这两个业务单元。

事实上，`nextWrapper(fn, id)` 支持指定一个唯一的异步任务队列 `id`。可以手动指定一个唯一的 `id`，如果不指定的话默认为 `default`，我推荐用 [next-wrapper](https://www.npmjs.com/package/next-wrapper) 提供的 `nextGenerator()` 方法来自动生成。因此，更合理的使用方式如下：

```JavaScript
const nextWrapper = require('next-wrapper')
const id = nextGenerator()
nextWrapper(function(next) {
    // 代码块
}, id)
nextWrapper(function(next) {
    // 代码块
}, id)
```

这样，即便有多人协作开发同一个项目，也可以保证彼此定义的异步任务队列按照预期的方式调用和执行。

# 总结

一般来说，如果嵌套不是很深，可以使用回调函数简单实现。如果超过两层以上的嵌套，回调函数就会变得很复杂，代码也不容易管理和阅读，对异常的捕捉也很可能考虑不全，很容易陷入我们总说的**回调地狱**。[next-wrapper](https://www.npmjs.com/package/next-wrapper) 在这种场景下提供了一种可行的解决方案，但事实上，就目前的 [next-wrapper](https://www.npmjs.com/package/next-wrapper) 所提供的功能来说，`Promise.prototype.then(onFulfilled, onRejected)` 做的要更好些，尤其是当需要对函数返回值做灵活处理的时候。
